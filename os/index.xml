<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Os on 张海余的主页</title>
    <link>https://fishwin.github.io/os/</link>
    <description>Recent content in Os on 张海余的主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 24 Nov 2022 19:31:18 +0800</lastBuildDate><atom:link href="https://fishwin.github.io/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IO密集型与CPU密集型区别</title>
      <link>https://fishwin.github.io/os/io%E5%AF%86%E9%9B%86%E5%9E%8B%E4%B8%8Ecpu%E5%AF%86%E9%9B%86%E5%9E%8B%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 24 Nov 2022 19:31:18 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/io%E5%AF%86%E9%9B%86%E5%9E%8B%E4%B8%8Ecpu%E5%AF%86%E9%9B%86%E5%9E%8B%E5%8C%BA%E5%88%AB/</guid>
      <description>  IO密集型
大部分时间是CPU在等待IO的读写操作（磁盘IO、网络IO），使用运行效率高的语言开发，无法明显提高性能
  CPU密集型
大部分时间执行计算、逻辑判断等CPU动作的程序称为CPU密集型，比如计算圆周率。CPU密集型程序适合用运行效率高的编程语言进行开发，如C语言
  </description>
    </item>
    
    <item>
      <title>TCP传输需要几次拷贝</title>
      <link>https://fishwin.github.io/os/tcp%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E5%87%A0%E6%AC%A1%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Thu, 24 Nov 2022 19:30:39 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/tcp%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E5%87%A0%E6%AC%A1%E6%8B%B7%E8%B4%9D/</guid>
      <description>参考：
https://www.cnblogs.com/f-ck-need-u/p/7624733.html</description>
    </item>
    
    <item>
      <title>零拷贝</title>
      <link>https://fishwin.github.io/os/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Thu, 24 Nov 2022 19:29:38 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid>
      <description>DMA (Direct Memory Access) 直接内存访问
负责数据搬运,解放CPU (CPU可以去处理别的事务,在DMA出现之前,数据搬运工作由CPU完成)
  传统文件传输过程
 应用程序调用read系统调用函数,切换到内核空间,并向内核发起读文件的指令 内核收到读指令后,接着向磁盘控制器发出读指令,然后通过DMA将数据拷贝到内核空间 内核将文件数据再拷贝到用户空间,read函数返回,完成一次用户空间与内核空间的切换 应用程序调用write系统调用函数,切换到内核空间,并将数据拷贝到内核的socket缓冲区中 write函数返回,完成一次用户空间与内核空间的切换 DMA将内核socket缓冲区中的数据拷贝到网卡中   总结  上述过程共发生了4次用户空间与内核空间的切换,read和write系统调用的调用和返回都会发生一次切换 共发生了4次数据拷贝,其中步骤2和6是DMA拷贝,步骤3和4是CPU拷贝 数据没必要拷贝到用户空间,浪费性能      使用mmap+write实现零拷贝
 应用程序调用mmap系统调用函数,切换到内核空间,并向内核发起读文件指令 内核向磁盘控制器发送读指令,DMA将文件数据拷贝到内核缓冲区中 mmap函数返回,切换回用户空间,并与用户空间共享内核缓冲区 应用程序调用write()系统调用函数,切换到内核空间,并将内核缓冲区中的数据拷贝到内核socket缓冲区 write函数返回,切换回用户空间 DMA将数据拷贝到网卡   总结  共发生了4次用户与内核空间的切换 共发生了3次拷贝,其中步骤4为CPU拷贝,步骤2和6为DMA拷贝 数据不会拷贝到用户空间,减少了一次CPU拷贝      sendfile实现零拷贝(linux 2.1版本)
  函数原型
// out_fd 目的端 // in_fd 源端 // offset 源端的偏移 // count 源端需要复制数据的长度 ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);   执行过程</description>
    </item>
    
    <item>
      <title>IO多路复用，select、poll、epoll区别</title>
      <link>https://fishwin.github.io/os/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Thu, 24 Nov 2022 19:28:33 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>IO多路复用是一种同步IO模型，一个线程监听多个IO事件，当有IO事件就绪时，就会通知线程去执行相应的读写操作，没有就绪事件时，就会阻塞交出cpu。多路是指网络链接，复用指的是复用同一线程。
  select
 fd_set数据结构定义如下，可以看出fd_set是一个整型数组，用于保存socket文件描述符  typedef long int __fd_mask; /* fd_set for select and pselect. */ typedef struct { #ifdef __USE_XOPEN  __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS]; # define __FDS_BITS(set) ((set)-&amp;gt;fds_bits) #else  __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS]; # define __FDS_BITS(set) ((set)-&amp;gt;__fds_bits) #endif  } fd_set;   执行过程
流程：
1. 用户线程调用select，将fd_set从用户空间拷贝到内核空间 2. 内核在内核空间对fd_set遍历一遍，检查是否有就绪的socket描述符，如果没有的话，就会进入休眠，直到有就绪的socket描述符 3. 内核返回select的结果给用户线程，即就绪的文件描述符数量 4. 用户拿到就绪文件描述符数量后，再次对fd_set进行遍历，找出就绪的文件描述符 5. 用户线程对就绪的文件描述符进行读写操作
  优点
 所有平台都支持，良好的跨平台性    缺点</description>
    </item>
    
    <item>
      <title>父进程与子进程之间的关系</title>
      <link>https://fishwin.github.io/os/%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Thu, 24 Nov 2022 19:24:35 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description>  fork函数
#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; int main() { int pid = fork(); if (pid == -1) return -1; if (pid) { printf(&amp;#34;I am father, my pid is %d\n&amp;#34;, getpid()); return 0; } else { printf(&amp;#34;I am child, my pid is %d\n&amp;#34;, getpid()); return 0; } }  fork函数调用一次返回两次 pid &amp;lt; 0 表示fork函数出错，位于父进程上下文 pid == 0 表示子进程，位于子进程上下文 pid &amp;gt; 0 表示父进程，pid为子进程的id，位于父进程上下文 父子进程执行顺序不确定，由内核调度算法决定    父进程与子进程之间的关系
 子进程是父进程的副本，子进程获得父进程数据空间、堆栈的副本（注意，这里是副本，与父进程不共享） 父子进程都有自己独立的地址空间，两进程独立运行。 子进程继承父进程的属性（几乎继承了所有）  环境变量 堆栈 当前工作目录 根目录 打开的文件描述符 用户和用户组 进程组 资源限制 等等   子进程独有  进程pid 父进程pid 记录锁 等等      孤儿进程，僵尸进程  孤儿进程  父进程执行结束后先退出，子进程仍然运行，这类子进程就被称为孤儿进程（父亲死了，但是儿子还在，自然称为孤儿） 对系统没有危害 孤儿进程会被init进程接管，进行资源回收，善后等操作（init可以理解为是孤儿院）   僵尸进程  子进程退出（exit或者异常等）父进程没有对其进行资源回收，改子进程仍然占据系统进程表，这类子进程称为僵尸进程（儿子死了，父亲不给他收尸） 因为其占据系统进程表，无法回收，一旦僵尸进程数量巨大，则系统无法创建新进程，所以对系统有危害 杀死父进程，该僵尸进程会被init进程接管，变为孤儿进程，init进程可对其进行资源回收善后    </description>
    </item>
    
    <item>
      <title>进程线程协程</title>
      <link>https://fishwin.github.io/os/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Thu, 24 Nov 2022 19:24:11 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description> 进程  操作系统进行资源分配和调度的基本单位 有独立的地址空间（一般为4G，地址空间又分为3G用户空间和1G内核空间） 进程间切换开销大 进程间是隔离的 进程之间使用IPC通信   线程  CPU调度的基本单元，一个进程至少包含一个线程 与同一进程的其他线程共享进程地址空间和资源 拥有自己的堆栈，寄存器和局部变量等 线程切换相对进程开销较小 线程间通过共享内存通信   协程  用户态的轻量级线程 调度由用户控制，避免了内核级别的上下文切换，如Goroutine由go运行时进行调度    </description>
    </item>
    
    <item>
      <title>IO模型</title>
      <link>https://fishwin.github.io/os/io%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 24 Nov 2021 19:25:48 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/io%E6%A8%A1%E5%9E%8B/</guid>
      <description>阻塞I/O
读写文件，网络I/O。当发生读写文件或网络I/O读写时，操作会阻塞当前线程，直到完成I/O操作，才能继续向下执行。
一般采用多进程或多线程的方式来解决此类问题，但是由于过多的进程或过多的线程都会造成大量的资源浪费，并且多线程上下文切换，也会带来很大的开销
执行流程：
1. 应用程序调用recvform()系统调用函数，进入内核空间 2. 内核空间等待数据准备好 3. 内核空间将数据从内核空间拷贝到用户空间 4. 应用程序拿到数据进行后续处理
总结：
​	上述整个过程，当前用户线程是阻塞等待的。
  非阻塞I/O
当应用程序调用系统调用函数，进入到内核空间后，如果内核空间数据没有准备好，那么此时内核空间之间返回给用户空间一个错误，此时用户空间不需要等待内核空间数据准备好，而可以去执行其他工作代码，然后定期轮询，查看内核空间是否准备好了，如果准备好，将内核空间中的数据拷贝到用户空间，应用收到数据后，继续执行后续的工作。
执行过程：
  应用程序发起系统调用，进入到内核空间
  如果内核空间数据还没准备好，则直接返回error。
  应用程序会定时轮询，数据是否准备好了
  数据准备好之后，则将数据从内核空间拷贝到用户空间
  应用程序拿到数据之后，进行后续处理
总结：
不管内核空间数据是否准备好，都直接返回，然后应用程序定时轮询内核空间，数据是否准备好，准备好之后则将数据从内核空间拷贝到用户空间。
    IO多路复用
一个线程可以监听多个I/O事件，当有事件就绪时，可以通知线程执行响应的工作代码。
执行过程：
1. 应用程序调用select系统调用函数，并将fd_set从用户空间拷贝到内核空间，然后在内核空间中对fd_se遍历一遍，如果没有就绪的I/O事件，则内核进行休	眠，当有就绪的事件时，则唤醒内核 2. 通知用户线程就绪事件的数量 3. 就绪数量大于0时，select再遍历一次fd_set，找出就绪的事件 4. 然后再执行相应的操作。比如：应用程序调用recvfrom系统调用，进入内核空间，内核将数据拷贝到用户空间进行后续处理
总结：
​	多路复用本质也是同步I/O
  信号驱动I/O
用户进程向内核发送一个信号，告诉内核需要什么样的数据，然后用户进程就可以去干其他工作了，当内核数据准备好后，就会给用户进程发送一个信号，去执行相应的读写操作。
执行过程：
1. 首先用户进程调用sigaction系统调用，告知内核需要什么数据，并返回一个sigio handler，用户进程就可以接着去干其他事儿了 2. 当内核数据准备好后，会给用户进程发送一个信号 3. 用户进程收到信号后，接着调用recvfrom系统调用，进入内核空间 4.</description>
    </item>
    
    <item>
      <title>虚拟内存</title>
      <link>https://fishwin.github.io/os/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 24 Nov 2020 19:31:49 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
      <description>个人理解
  执行过程
在执行一个可执行文件时，内核首先为这个进程创建一份逻辑地址空间，进程看到的逻辑地址空间是线性连续的（一般为4G）逻辑地址空间到物理地址空间，逻辑地址空间到磁盘地址空间都会会做一个页映射，程序运行时，并不会把所有数据都加载到物理内存中，而只是将必须的加载到物理内存，当通过逻辑地址查找物理地址时，首先通过MMU将逻辑地址转化为物理内存地址并校验合法性，然后查看页表，发现在页表中不存在该数据，就会发生页中断，这时就把数据从磁盘交换到物理内存，如果当前物理内存已没有额外的空间，那么就会产生页覆盖，具体覆盖哪些页，由操作系统决定，一般采用LRU算法进行页淘汰。
  如果保证进程地址空间隔离
逻辑地址与物理内存中间有一层MMU（内存管理单元），它会将逻辑地址转换为物理地址，会对每个进程的地址进行检查，每个进程会被限制只能访问物理内存中某一段的地址空间，如果不在这个区间内，那么就认为地址非法。
  内存存储方式
 段式存储  段号 段偏移 堆段、栈段、数据段、代码段等 将内存空间分为不同长度的区间块   页式存储  页号 页偏移 页表 将内存空间分为相同长度的区间块      内存碎片
  定义
由于内存不断分配，而造成的，一些极小的内存块，不能满足新的内存分配需求大小，从而导致这些内存不能被利用。
  解决方案
 压缩法：将所有已分配的内存块，通过移动，紧凑的放到一起      注意
系统公用函数可在物理内存中只存储一份，供多个进程使用
    进程逻辑地址空间划分
一般1/4是内核地址空间，3/4是用户地址空间
  虚拟内存解决了什么问题？
可以使每个进程有独立的内存空间，相互隔离
  进程地址空间划分
一般1/4是内核地址空间，3/4是用户地址空间
  页表
建立逻辑地址空间与物理内存地址空间的映射，建立逻辑地址空间与磁盘地址空间的映射
每个页表项都分为两部分，第一部分记录此页是否在物理内存中，第二部分记录物理内存页的地址（如果存在）</description>
    </item>
    
    <item>
      <title>并行与并发</title>
      <link>https://fishwin.github.io/os/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Sun, 24 Nov 2019 19:23:36 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/</guid>
      <description> 并行：同一时刻多个任务同时执行 并发：一个时间段内执行多个任务，不一定同一时刻执行，一般是交替执行  </description>
    </item>
    
    <item>
      <title>操作系统八股文</title>
      <link>https://fishwin.github.io/os/ms/</link>
      <pubDate>Sun, 13 Jan 2019 10:56:13 +0800</pubDate>
      
      <guid>https://fishwin.github.io/os/ms/</guid>
      <description>进程和线程之间有什么区别？ 【[腾讯,阿里,字节跳动,美团,京东,百度,滴滴,快手,拼多多]，简单，398次】  参考一：https://www.guru99.com/difference-between-process-and-thread.html 参考二：https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/c%2B%2B/concurrent/1.%20Linux%20%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6.pdf  进程间有哪些通信方式？ 【[腾讯,阿里,字节跳动,美团,百度,滴滴,快手,拼多多]，困难，358次】  参考一：https://www.guru99.com/inter-process-communication-ipc.html 参考二：https://www.coursera.org/lecture/os-pku/jin-cheng-jian-tong-xin-ipc-wbxs5  简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？ 【[腾讯,阿里,字节跳动,美团,百度,滴滴,拼多多]，困难，253次】  参考一：https://jvns.ca/blog/2017/06/03/async-io-on-linux&amp;ndash;select&amp;ndash;poll&amp;ndash;and-epoll/ 参考二：https://imageslr.com/2020/02/27/select-poll-epoll.html  简述 Linux 进程调度的算法 【[腾讯,字节跳动,美团,百度,拼多多]，困难，138次】  参考一：https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/c%2B%2B/concurrent/1.%20Linux%20%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6.pdf  简述几个常用的 Linux 命令以及他们的功能 【[腾讯,阿里,百度,拼多多]，简单，114次】 简述操作系统如何进行内存管理 【[腾讯,腾讯,字节跳动]，中等，110次】  参考一：https://www.guru99.com/os-memory-management.html 参考二：https://zhuanlan.zhihu.com/p/143273007  线程有多少种状态，状态之间如何转换 【[阿里,京东]，简单，60次】 线程间有哪些通信方式？ 【[腾讯,字节跳动]，中等，52次】 简述操作系统中的缺页中断 【[腾讯,字节跳动]，中等，52次】  参考一：https://www.oreilly.com/library/view/understanding-the-linux/0596005652/ch04s02.html  什么时候会由用户态陷入内核态？ 【[腾讯,字节跳动]，简单，48次】 简述自旋锁与互斥锁的使用场景 【[字节跳动,快手]，中等，44次】 进程有多少种状态？ 【[阿里,百度]，简单，44次】 Linux 下如何查看端口被哪个进程占用？ 【[腾讯,字节跳动]，简单，42次】 操作系统中，虚拟地址与物理地址之间如何映射？ 【[字节跳动]，中等，40次】 简述 Linux 系统态与用户态，什么时候会进入系统态？ 【[腾讯]，简单，32次】  参考一：https://www.redhat.com/en/blog/architecting-containers-part-1-why-understanding-user-space-vs-kernel-space-matters  创建线程有多少种方式？ 【[京东]，中等，28次】 简述同步与异步的区别，阻塞与非阻塞的区别 【[腾讯]，困难，26次】 简述 Linux 零拷贝的原理 【[阿里,字节跳动]，中等，26次】 Linux 中虚拟内存和物理内存有什么区别？有什么优点？ 【[腾讯,字节跳动]，中等，26次】 BIO、NIO 有什么区别？怎么判断写文件时 Buffer 已经写满？简述 Linux 的 IO模型 【[腾讯]，困难，22次】 简述 mmap 的使用场景以及原理 【[字节跳动]，中等，20次】 简述操作系统中 malloc 的实现原理 【[腾讯]，中等，18次】 Linux 下如何排查 CPU 以及 内存占用过多？ 【[阿里]，简单，18次】 两个线程交替打印一个共享变量 【[字节跳动]，中等，18次】 多线程和多进程的区别是什么？ 【[美团]，简单，16次】 共享内存是如何实现的？ 【[滴滴]，，16次】 进程通信中的管道实现原理是什么？ 【[阿里]，简单，16次】 Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？ 【[阿里]，简单，16次】 Linux 如何查看实时的滚动日志？ 【[阿里]，简单，14次】 如何调试服务器内存占用过高的问题？ 【[阿里]，中等，14次】 malloc 创建的对象在堆还是栈中？ 【[滴滴]，简单，14次】 为什么进程切换慢，线程切换快？ 【[美团]，简单，14次】 简述创建进程的流程 【[美团]，中等，14次】 简述 Linux 虚拟内存的页面置换算法 【[美团]，中等，14次】 简述 CPU L1, L2, L3 多级缓存的基本作用 【[京东]，简单，14次】 进程空间从高位到低位都有些什么？ 【[腾讯]，简单，12次】 简述 Linux 的 I/O模型 【[滴滴]，，12次】 什么情况下，进程会进行切换？ 【[字节跳动]，简单，12次】 信号量是如何实现的？ 【[滴滴]，，10次】 简述 traceroute 命令的原理 【[字节跳动]，简单，10次】 Linux 页大小是多少？ 【[滴滴]，简单，10次】 进程和线程之间有什么区别？ 【[Shopee]，简单，28次】  参考一：https://www.</description>
    </item>
    
  </channel>
</rss>
