<!DOCTYPE html>
<html class="no-js" lang="zh-CN">
<head>
	<meta name="generator" content="Hugo 0.92.0" />
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>张海余的主页</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="张海余的个人博客">
		<meta property="og:title" content="张海余的主页" />
<meta property="og:description" content="张海余的个人博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://fishwin.github.io/" />


		<meta itemprop="name" content="张海余的主页">
<meta itemprop="description" content="张海余的个人博客">
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="张海余的主页"/>
<meta name="twitter:description" content="张海余的个人博客"/>

	<link rel="stylesheet" href="/css/bundle.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="stylesheet" href="/css/themes/dark-green.css">
	<link rel="icon" href="/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="/icons/32.png" sizes="32x32" type="image/png">
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="张海余的主页">
	<link rel="manifest" href="/manifest.json">
		
</head>
<body class="body kind-home">
	<header class="header">
	<a class="logo" href="/">张海余的主页</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="/">
					
					<span class="main-nav__text">首页</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/golang/">
					
					<span class="main-nav__text">Go</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/os/">
					
					<span class="main-nav__text">操作系统</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/net/">
					
					<span class="main-nav__text">网络协议</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/distributiton/">
					
					<span class="main-nav__text">分布式</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/sysdesign/">
					
					<span class="main-nav__text">系统设计</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/algorithm/">
					
					<span class="main-nav__text">算法</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/db/">
					
					<span class="main-nav__text">数据库</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/middleware/">
					
					<span class="main-nav__text">中间件</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/othertech/">
					
					<span class="main-nav__text">谈古论今</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/about/">
					
					<span class="main-nav__text">关于</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
			<div class="cards">
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/tcp%E5%9B%9B%E5%85%83%E7%BB%84/">TCP四元组</a></h1>
	<div class="entry__content">TCP四元组包括源地址、源端口、目的地址、目的端口
源地址和目标地址的字段在IP头部
源端口和目标端口的字段在TCP头部</div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:46:25&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/">服务器最大连接数</a></h1>
	<div class="entry__content">多个客户端连接到服务器只消耗服务器一个端口，即监听的端口。同一个客户端向服务器建立多个连接，会消耗客户端所在机器多个随机端口。
理论上服务器最大连接数非常大，但是每一个TCP连接会占用内存，服务器的内存有限，每个socket还会消耗一个文件描述符，也是有上限的。</div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:46:00&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/">网络分层</a></h1>
	<div class="entry__content">ARP协议 通过IP地址获取物理地址
ARQ协议 Automatic Repeat-reQuest
自动重传请求，通过确认和超时机制
连续ARQ协议采用流水线传输，一次性发送多个分组，而不用等待每个分组的确认，提高信道利用率，通常结合滑动窗口协议实现。
OSI七层网络协议 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
TCP/IP协议 应用层、传输层、网络层、网络接口层</div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:45:26&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">Tcp 滑动窗口、流量控制和拥塞控制</a></h1>
	<div class="entry__content">滑动窗口
 为了解决发送一个分组必须等待确认才能发送下一个分组的性能不高的问题 引入窗口的概念，一次可发送多个数组，累计确认，提高通信效率 窗口大小由接收端决定，接收端通过tcp头部的window字段告知发送端还有多大缓冲区可以接收数据 发送方和接收方都有窗口，并且不断向前滑动    流量控制
  接收方通过TCP头部的window字段，来不断告知还可以接收的数据量，来控制发送数据量，这期间发送窗口的大小会随接收窗口大小不断变化
  窗口关闭问题
窗口关闭问题即发送窗口为0，这时发送窗口不会再发送数据，但是当接收窗口变大可接收数据时，发送方并不知道，为解决这一问题，发送方会定时进行窗口探测，接收方在收到探测报文之后，会告知自己的窗口大小。
    拥塞控制
 避免大数量数据传输导致网络拥堵，进而导致数据报丢失 拥塞窗口：为了实现拥塞控制，在发送端设置的窗口，发送窗口大小=min(拥塞窗口大小，接收窗口大小) 如果发送方在规定时间内没有收到接收方的确认消息，就认为网络拥堵 控制算法  慢启动：tcp刚建立连接时，发送方每收到一个ack，拥塞窗口就乘2，直到增加到ssthresh（慢启动门限）&mdash;-指数增长 拥塞避免算法：当拥塞窗口大小超过ssthresh（慢启动门限）时，就会进入拥塞避免，即每当收到一个ack，拥塞窗口大小增加1/拥塞窗口大小&mdash;-线性增长，窗口大小增速减缓 拥塞发生&mdash;变化拥塞窗口大小  发生超时重传的拥塞发生算法：慢启动门限设置为拥塞窗口的一半，拥塞窗口大小设置为1 发生快速重传的拥塞发生算法：拥塞窗口大小减半，慢启动门限设置为原拥塞窗口大小，快速恢复算法   快速恢复：当发送端连续收到三个连续确认，执行快速重传，并进入快速恢复阶段，慢启动门限和拥塞窗口大小都减为当前拥塞窗口的一半。      流量控制与拥塞控制比较
 流量控制是发送方根据接收方窗口大小来变化发送窗口大小 拥塞控制是针对整个网络拥堵情况，进行调整拥塞窗口的大小    参考
https://www.cnblogs.com/xiaolincoding/p/12732052.html
  TCP 累计确认 ack=n表示n之前的数据已经正确收到
TCP 快速重传 当发送方收到连续三个相同序列号的ack，那么这个时候就会重发这个序列号之后的数据，不需要等待超时，提高效率</div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:44:14&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/tcp%E4%B8%8Eudp%E5%A4%B4%E9%83%A8/">TCP与UDP头部</a></h1>
	<div class="entry__content">UDP头部   示意图
  数据字典
 目标和源端口：标识进程 包长度：UDP头部和数据的长度之和 校验和：提供可靠的UDP头部和数据(相当于对数据进行签名，发送端计算一个校验和，再接收端再计算一次，并与头部的校验和进行比对)    代码定义
/*UDP头定义，共8个字节*/ typedef struct _UDP_HEADER { unsigned short m_usSourPort; // 源端口号16bit  unsigned short m_usDestPort; // 目的端口号16bit  unsigned short m_usLength; // 数据包长度16bit  unsigned short m_usCheckSum; // 校验和16bit }__attribute__((packed))UDP_HEADER, *PUDP_HEADER;     TCP头部   示意图
  词典
 序列号：随机生成，用来解决包重复、乱序、重传等问题 确认应答号：解决不丢包的问题 控制位  ACK：确认应答，该位为1时，确认应答号字段有效 RST：该位为1时，表示TCP连接异常必须强制断开连接 SYN：该位为1时，表示希望建立连接，并完成序列号的初始化 FIN：该位为1时，表示希望断开连接      校验和：类似于对数据进行签名，在接收端进行校验</div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:41:15&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a></h1>
	<div class="entry__content">https://www.cnblogs.com/xiaolincoding/p/12732052.html</div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:40:27&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">TCP四次挥手</a></h1>
	<div class="entry__content">TCP四次挥手过程   执行流程图
 执行过程  客户端向服务端发送FIN报文（FIN=1，seq=u），并进入FIN_WAIT_1状态 服务端收到FIN报文后，向客户端回复确认报文（ACK=1,seq=v,ack=u+1），并进入到CLOSE_WAIT状态 当前处于半关闭状态，客户端不能向服务端发送数据报文，但是服务端可以向客户端发送数据报文 服务端向客户端发送FIN报文(FIN=1,ACK=1,seq=w,ack=u+1),并进入到LAST_ACK状态 客户端收到FIN报文后，向服务端回复确认报文（ACK=1,seq=u+1,ack=w+1）并进入到TIME_WAIT状态 服务端收到之后进入到CLOSED状态 客户端等待2MSL（MSL表示最大报文生存时间，任何报文超过这个时间都会被丢弃）后也进入到CLOSED状态      参考：
https://blog.csdn.net/qzcsu/article/details/72861891
为什么TCP断开链接需要4次挥手 因为TCP连接是全双工的，两个方向都需要单独关闭。
TCP四次挥手中出现CLOSE_WAIT状态的原因？ 服务端需要处理完手头剩余的工作即发送完需要发送的所有数据（协议层需要等待应用层主动调用close才会进行关闭操作），然后向服务端发送FIN包
线上出现大量CLOSE_WAIT原因  原因  被动关闭方应用层没有正确调用close方法关闭连接 cpu繁忙   危害  资源占用（文件描述符，端口等），无法响应建立新连接   解决方法  排查代码，是否能正常close连接    TIME_WAIT原因，为什么要等待2MSL  为了保证客户端发给服务端的最后一个ACK报文到达服务端，如果服务端没收到的话，会重传FIN包，这时客户端需要重新发送ACK包（重新计时2MSL）。否则，如果ACK包丢失的话，服务端无法进入CLOSED状态。TIME_WAIT状态就是用来重传可能丢失的ACK包 使本链接中产生的所有的请求报文从网络中消失（MSL为最大报文生存时间），防止在相同四元组建立新连接时，其中再出现这些旧报文  线上出现很多TIME_WAIT为什么？  原因  服务端主动关闭连接，tcp连接进入TIME_WAIT状态   解决方法  内核参数调优（修改TIME_WAIT等待时间），但只治标不治本    </div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:38:54&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/tcp/">Tcp</a></h1>
	<div class="entry__content">1. TCP定义 TCP是面向连接的、可靠的、基于字节流的传输层通信协议 。
2. 什么是TCP连接 用于保证可靠性和流量控制的某些状态信息的组合，包括socket、序列号、窗口大小等
3. TCP与UDP区别，UDP优点，适用场景   区别
  连接
TCP是面向连接的传输层协议，通信之前需要建立连接
UDP传输时不需要建立连接
  服务对象
TCP只能一对一通信
UDP支持一对一、一对多、多对多
  可靠性
TCP保证数据传输的可靠性
UDP不保证传输的可靠性
  拥塞控制、流量控制
TCP有拥塞控制和流量控制的机制
UDP没有
  首部开销
TCP首部20个字节（不使用选项字段20字节、使用时更长），UDP首部只有8个字节，长度固定
    应用案例
 TCP  FTP文件传输 HTTP/HTTPS   UDP  DNS 视频、音频等多媒体通信      参考：
https://www.cnblogs.com/xiaolincoding/p/12638546.html
4. Linux查看TCP连接状态   命令
netstat -napt
  图
  </div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:36:10&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/https%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/">Https原理及握手过程</a></h1>
	<div class="entry__content">  原理
https本质是在原http与tcp之间加入了SSL/TLS协议
https = http + ssl/tls
  https七次握手过程
 客户端向服务端发送SYN消息，并进入SYN_SENT状态 服务端收到SYN报文后，回复SYN+ACK报文，并进入SYN_RECV状态 客户端回复ACK，双方进入ESTABLISHED状态，建立TCP连接 客户端向服务端发送Client Hello消息，并携带客户端支持的协议版本号、加密算法、随机数（32位）等信息。 服务端收到之后，向客户端发送Server Hello消息，并携带证书（包含公钥等信息）、服务端生成的随机数、会话ID、协议版本等信息。 客户端收到服务端消息后，验证证书，向服务端发送Client key exchange消息，客户端再生成一个随机数，并使用服务端传过来的证书公钥对其进行加密作为预主密钥（pre master key），并通知服务端之后加密传输，并发送finished消息。 服务端收到消息之后，回复finished消息，并通知客户端之后数据加密传输  注意：主密钥由双方产生的随机数和预主密钥生成
master_secret = PRF(pre_master_secret,&#34;master secret&#34;,ClientHello.random+ServerHello.random)   参考
https://draveness.me/whys-the-design-https-latency/
https://razeencheng.com/post/ssl-handshake-detail
https://segmentfault.com/a/1190000021494676
  </div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:33:44&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/net/%E5%B8%B8%E8%A7%81httpheader/">常见http header</a></h1>
	<div class="entry__content">常见的http请求头
   协议头 说明 示例     Accept 可接受的响应内容类型（Content-Types） Accept:text/plain   Accept-Charset 可接受的字符集 Accept-Charset:utf-8   Accept-Encoding 可接受的响应内容编码方式 Accept-Encoding: gzip, deflate   Accept-Language 可接受的响应内容的语言列表 Accept-Language: en-US   Authorization 认证信息 Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==   Cache-Control 是否使用缓存机制 Cache-Control: no-cache   Connection 客户端（浏览器）想要优先使用的连接类型 Connection: keep-alive Connection: Upgrade   Cookie 由之前服务器设置的一个Cookie Cookie: $Version=1; Skin=new;   Content-Length 以8进制表示的请求体的长度 Content-Length: 348   Content-Type 请求体的MIME类型，用于POST和PUT Content-Type: application/x-www-form-urlencoded   Date 日期时间 Date: Dec, 26 Dec 2015 17:30:00 GMT   Host 服务器域名 Host: www.</div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2022-11-24T17:33:08&#43;08:00">2022年11月24日</time>
	</div>
</article>
					</div>
			</div>
	</main>
	
<div class="pagination block">
				<span class="pagination__item pagination__item--active" data-total="2">1</span>
				<a class="pagination__item pagination__item--desktop" href="/page/2/">2</a>
</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:zhanghaiyu@hellogroup.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/fishwin">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
</div>
	<div class="footer__copyright">© 2022 张海余的主页. <span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span></div>
</footer>
<script src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
</body>
</html>